<?php

/*
 * This file is part of PostCarrier for EC-CUBE
 *
 * Copyright(c) IPLOGIC CO.,LTD. All Rights Reserved.
 *
 * http://www.iplogic.co.jp/
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Plugin\PostCarrier4\Repository;

use Doctrine\Common\Collections\ArrayCollection;
use Eccube\Common\Constant;
use Eccube\Entity\Master\CustomerStatus;
use Eccube\Repository\AbstractRepository;
use Eccube\Util\StringUtil;
use Plugin\PostCarrier4\Entity\PostCarrierGroup;
use Plugin\PostCarrier4\Entity\PostCarrierGroupCustomer;
use Symfony\Bridge\Doctrine\RegistryInterface;

/**
 * PostCarrierGroup.
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class PostCarrierGroupCustomerRepository extends AbstractRepository
{
    /**
     * PostCarrierGroupRepository constructor.
     *
     * @param RegistryInterface $registry
     */
    public function __construct(RegistryInterface $registry)
    {
        parent::__construct($registry, PostCarrierGroupCustomer::class);
    }

    public function getQueryBuilderBySearchData($searchData, $is_event_on = false)
    {
        $qb = $this->createQueryBuilder('c')
            ->select('c');

        if (!empty($searchData['Group']) && count($searchData['Group']) > 0) {
            $Groups = [];
            foreach($searchData['Group'] as $Group) {
                $Groups[] = $Group->getId();
            }

            $qb
                ->andWhere($qb->expr()->in('c.group_id', ':groups'))
                ->setParameter('groups', $Groups);

            // グループ間重複排除
            if (count($searchData['Group']) > 1) {
                $qb2 = $this->_em->createQueryBuilder();
                $qb2->select('1')
                    ->from('Plugin\PostCarrier4\Entity\PostCarrierGroupCustomer', 'c2')
                    ->andWhere('c.email = c2.email')
                    ->andWhere($qb2->expr()->in('c2.group_id', ':c2_groups'))
                    ->setParameter('c2_groups', $Groups)
                    ->andWhere('c.id < c2.id');

                $qb
                    ->andWhere($qb->expr()->not($qb->expr()->exists($qb2->getDQL()))) // NOT EXISTS
                    ->setParameters(new ArrayCollection(array_merge($qb->getParameters()->toArray(),
                                                                    $qb2->getParameters()->toArray())));
            }

        }

        // メルマガ希望フラグを無視する
        // 希望しない情報が存在しない事を確認。希望する情報が存在する事を確認するとEC会員登録がないメルマガ専用会員ガ抽出されない。
        if (!isset($searchData['ignore_permissions']) || !$searchData['ignore_permissions']) {
            $qb3 = $this->_em->createQueryBuilder();
            $qb3->select('1')
                ->from('\Eccube\Entity\Customer', 'c3')
                ->andWhere('c.email = c3.email')
                ->andWhere('c3.postcarrier_flg = :c3_postcarrier_flg')
                ->setParameter('c3_postcarrier_flg', Constant::DISABLED)
                // TODO 無視すべき？
                ->andWhere('c3.Status = :c3_status')
                ->setParameter('c3_status', CustomerStatus::REGULAR);

            $qb
                ->andWhere($qb->expr()->not($qb->expr()->exists($qb3->getDQL()))) // NOT EXISTS
                ->setParameters(new ArrayCollection(array_merge($qb->getParameters()->toArray(),
                                                                $qb3->getParameters()->toArray())));
        }

        // TODO 複数アドレス対応
        if (isset($searchData['email']) && StringUtil::isNotBlank($searchData['email'])) {
            $qb
                ->andWhere('c.email LIKE :email')
                ->setParameter('email', '%'.$searchData['email'].'%');
        }

        if (!empty($searchData['create_date_start']) && $searchData['create_date_start']) {
            $qb
                ->andWhere('c.create_date >= :create_date_start')
                ->setParameter('create_date_start', $searchData['create_date_start']);
        }
        if (!empty($searchData['create_date_end']) && $searchData['create_date_end']) {
            $date = clone $searchData['create_date_end'];
            $date->modify('+1 days');
            $qb
                ->andWhere('c.create_date < :create_date_end')
                ->setParameter('create_date_end', $date);
        }

        if ($is_event_on && isset($searchData['b__event'])) {
            $eventColumnMap = [
                'memberRegistrationDate' => 'c.create_date',
            ];

            $eventColumn = $eventColumnMap[$searchData['b__event']];
            $offsetSign = $searchData['b__eventDaySelect'] === 'front' ? '+' : '-';
            $offsetDays = $searchData['b__eventDay'];

            if ($searchData['b__event'] == 'memberRegistrationDate') {
                $step_begin = (new \DateTime("-${offsetDays} day"))->setTime(0, 0);
                $step_end = (clone $step_begin)->modify('+1 day');

                $qb
                    ->andWhere(":step_begin <= $eventColumn")
                    ->andWhere("$eventColumn < :step_end")
                    ->setParameter('step_begin', $step_begin)
                    ->setParameter('step_end', $step_end);
            } else {
                assert(false);
            }
        }

        return $qb;
    }

    /**
     * ユニークなシークレットキーを返す.
     *
     * @return string
     */
    public function getUniqueSecretKey()
    {
        do {
            $key = StringUtil::random(32);
            $MailCustomer = $this->findOneBy(['secret_key' => $key]);
        } while ($MailCustomer);

        return $key;
    }
}
